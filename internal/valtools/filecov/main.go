// Copyright 2024 Metrum Research Group
// SPDX-License-Identifier: MIT

package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/mod/modfile"
	"golang.org/x/tools/cover"
)

const usageMessage = `usage: filecov [-mod=<file>] <profile>

Calculate the coverage for each file in <profile> along with the overall
coverage and write the JSON result to standard output.  <profile> is a coverage
profile in the format generated by 'go test' for its -coverprofile argument.

Options:

  -mod=<file>
   The file entries in <profile> are prefixed with the module name (e.g.,
   "example.com/mod/cmd/foo.go") or, in some cases, the absolute path to the
   file.  If you pass a module's go.mod to this option, the module name from
   that file is stripped from the file names in the output (yielding, e.g.,
   "cmd/foo.go").  This is particularly useful in the common case where all the
   files belong to the same module.  `

var (
	gomod = flag.String("mod", "", "")
)

func usage() {
	fmt.Fprint(flag.CommandLine.Output(), usageMessage)
}

type tally struct {
	covered int64
	total   int64
}

func tallyCovered(p *cover.Profile) tally {
	// This follows Go's src/cmd/cover/html.go.
	var total, covered int64
	for _, b := range p.Blocks {
		total += int64(b.NumStmt)
		if b.Count > 0 {
			covered += int64(b.NumStmt)
		}
	}

	return tally{covered: covered, total: total}
}

type fileCoverage struct {
	File     string  `json:"file"`
	Coverage float64 `json:"coverage"`
}

type coverage struct {
	Overall float64         `json:"overall"`
	Files   []*fileCoverage `json:"files"`
}

func percent(covered int64, total int64) float64 {
	if total == 0 {
		return 0
	}

	return float64(covered) / float64(total) * 100
}

func percentCovered(profiles []*cover.Profile) coverage {
	var total, covered int64
	var fcovs []*fileCoverage

	for _, profile := range profiles {
		ftally := tallyCovered(profile)
		fcovs = append(fcovs,
			&fileCoverage{
				File:     profile.FileName,
				Coverage: percent(ftally.covered, ftally.total),
			},
		)
		covered += ftally.covered
		total += ftally.total
	}

	return coverage{Overall: percent(covered, total), Files: fcovs}
}

func shortenFileNames(cov coverage, modpath string, localpath string) error {
	if modpath == "" {
		return nil
	}

	mprefix := modpath + "/"
	sep := string(filepath.Separator)

	var lprefix string
	if localpath != "" {
		lpath, err := filepath.EvalSymlinks(localpath)
		if err != nil {
			return err
		}
		lprefix = lpath + string(filepath.Separator)
	}

	for _, entry := range cov.Files {
		var prefix, file string
		var err error
		if lprefix != "" && strings.HasPrefix(entry.File, sep) {
			// For the executable, Go writes a path like
			// /path/to/bbi/cmd/bbi/main.go instead of the module-prefixed name
			// (github.com/metrumresearchgroup/bbi/...) that it writes for the
			// other files.
			file, err = filepath.EvalSymlinks(entry.File)
			if err != nil {
				return err
			}
			prefix = lprefix
		} else {
			file = entry.File
			prefix = mprefix
		}
		entry.File = strings.TrimPrefix(file, prefix)
	}

	return nil
}

func write(w io.Writer, profiles []*cover.Profile, modpath string, localpath string) error {
	cov := percentCovered(profiles)
	if modpath != "" {
		if err := shortenFileNames(cov, modpath, localpath); err != nil {
			return err
		}
	}

	bs, err := json.MarshalIndent(cov, "", "  ")
	if err != nil {
		return err
	}
	_, err = w.Write(append(bs, []byte("\n")...))

	return err
}

func run(input string, gomod string, w io.Writer) error {
	profiles, err := cover.ParseProfiles(input)
	if err != nil {
		return err
	}

	var mpath, lpath string
	if gomod != "" {
		gomod, err = filepath.Abs(gomod)
		if err != nil {
			return err
		}

		mod, err := os.ReadFile(gomod)
		if err != nil {
			return err
		}

		mpath = modfile.ModulePath(mod)
		if mpath == "" {
			return fmt.Errorf("could not find module path in %q", gomod)
		}

		lpath = filepath.Dir(gomod)
	}

	return write(w, profiles, mpath, lpath)
}

func main() {
	if len(os.Args) > 1 && (os.Args[1] == "-h" || os.Args[1] == "--help") {
		flag.CommandLine.SetOutput(os.Stdout)
	}
	flag.Usage = usage
	flag.Parse()
	args := flag.Args()

	if len(args) != 1 {
		flag.Usage()
		os.Exit(2)
	}

	if err := run(args[0], *gomod, os.Stdout); err != nil {
		fmt.Fprintln(os.Stderr, "error:", err)
		os.Exit(2)
	}
}
